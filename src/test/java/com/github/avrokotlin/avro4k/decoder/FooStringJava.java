
/**
 * Autogenerated by Avro
 * <p>
 * DO NOT EDIT DIRECTLY
 */

package com.github.avrokotlin.avro4k.decoder;

import org.apache.avro.Schema;
import org.apache.avro.data.RecordBuilder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.SchemaStore;
import org.apache.avro.specific.*;


/**
 * This is a java class generated with the official avro maven plugin. Used for interoperability testing
 * with kotlinx/avro4k.
 * <p>
 * It is identical with the schema defined in FooString, but we have to give it a different name because
 * avro default uses Class.forName resolution.
 */
@AvroGenerated
public class FooStringJava extends SpecificRecordBase implements SpecificRecord {
   private static final long serialVersionUID = 3055573591170182772L;


   public static final Schema SCHEMA$ = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"FooStringJava\",\"namespace\":\"com.github.avrokotlin.avro4k.decoder\",\"fields\":[{\"name\":\"str\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}}]}");

   public static Schema getClassSchema() {
      return SCHEMA$;
   }

   private static final SpecificData MODEL$ = new SpecificData();

   private static final BinaryMessageEncoder<FooStringJava> ENCODER =
      new BinaryMessageEncoder<>(MODEL$, SCHEMA$);

   private static final BinaryMessageDecoder<FooStringJava> DECODER =
      new BinaryMessageDecoder<>(MODEL$, SCHEMA$);

   /**
    * Return the BinaryMessageEncoder instance used by this class.
    *
    * @return the message encoder used by this class
    */
   public static BinaryMessageEncoder<FooStringJava> getEncoder() {
      return ENCODER;
   }

   /**
    * Return the BinaryMessageDecoder instance used by this class.
    *
    * @return the message decoder used by this class
    */
   public static BinaryMessageDecoder<FooStringJava> getDecoder() {
      return DECODER;
   }

   /**
    * Create a new BinaryMessageDecoder instance for this class that uses the specified {@link SchemaStore}.
    *
    * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
    * @return a BinaryMessageDecoder instance for this class backed by the given SchemaStore
    */
   public static BinaryMessageDecoder<FooStringJava> createDecoder(SchemaStore resolver) {
      return new BinaryMessageDecoder<>(MODEL$, SCHEMA$, resolver);
   }

   /**
    * Serializes this FooString to a ByteBuffer.
    *
    * @return a buffer holding the serialized data for this instance
    * @throws java.io.IOException if this instance could not be serialized
    */
   public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
      return ENCODER.encode(this);
   }

   /**
    * Deserializes a FooString from a ByteBuffer.
    *
    * @param b a byte buffer holding serialized data for an instance of this class
    * @return a FooString instance decoded from the given buffer
    * @throws java.io.IOException if the given bytes could not be deserialized into an instance of this class
    */
   public static FooStringJava fromByteBuffer(
      java.nio.ByteBuffer b) throws java.io.IOException {
      return DECODER.decode(b);
   }

   private java.lang.String str;

   /**
    * Default constructor.  Note that this does not initialize fields
    * to their default values from the schema.  If that is desired then
    * one should use <code>newBuilder()</code>.
    */
   public FooStringJava() {
   }

   /**
    * All-args constructor.
    *
    * @param str The new value for str
    */
   public FooStringJava(java.lang.String str) {
      this.str = str;
   }

   @Override
   public org.apache.avro.specific.SpecificData getSpecificData() {
      return MODEL$;
   }

   @Override
   public Schema getSchema() {
      return SCHEMA$;
   }

   // Used by DatumWriter.  Applications should not call.
   @Override
   public java.lang.Object get(int field$) {
      switch (field$) {
         case 0:
            return str;
         default:
            throw new IndexOutOfBoundsException("Invalid index: " + field$);
      }
   }

   // Used by DatumReader.  Applications should not call.
   @Override
   @SuppressWarnings(value = "unchecked")
   public void put(int field$, java.lang.Object value$) {
      switch (field$) {
         case 0:
            str = value$ != null ? value$.toString() : null;
            break;
         default:
            throw new IndexOutOfBoundsException("Invalid index: " + field$);
      }
   }

   /**
    * Gets the value of the 'str' field.
    *
    * @return The value of the 'str' field.
    */
   public java.lang.String getStr() {
      return str;
   }


   /**
    * Creates a new FooString RecordBuilder.
    *
    * @return A new FooString RecordBuilder
    */
   public static Builder newBuilder() {
      return new Builder();
   }

   /**
    * Creates a new FooString RecordBuilder by copying an existing Builder.
    *
    * @param other The existing builder to copy.
    * @return A new FooString RecordBuilder
    */
   public static Builder newBuilder(Builder other) {
      if (other == null) {
         return new Builder();
      } else {
         return new Builder(other);
      }
   }

   /**
    * Creates a new FooString RecordBuilder by copying an existing FooString instance.
    *
    * @param other The existing instance to copy.
    * @return A new FooString RecordBuilder
    */
   public static Builder newBuilder(FooStringJava other) {
      if (other == null) {
         return new Builder();
      } else {
         return new Builder(other);
      }
   }

   /**
    * RecordBuilder for FooString instances.
    */
   @AvroGenerated
   public static class Builder extends SpecificRecordBuilderBase<FooStringJava> implements RecordBuilder<FooStringJava> {

      private java.lang.String str;

      /**
       * Creates a new Builder
       */
      private Builder() {
         super(SCHEMA$, MODEL$);
      }

      /**
       * Creates a Builder by copying an existing Builder.
       *
       * @param other The existing Builder to copy.
       */
      private Builder(Builder other) {
         super(other);
         if (isValidValue(fields()[0], other.str)) {
            this.str = data().deepCopy(fields()[0].schema(), other.str);
            fieldSetFlags()[0] = other.fieldSetFlags()[0];
         }
      }

      /**
       * Creates a Builder by copying an existing FooString instance
       *
       * @param other The existing instance to copy.
       */
      private Builder(FooStringJava other) {
         super(SCHEMA$, MODEL$);
         if (isValidValue(fields()[0], other.str)) {
            this.str = data().deepCopy(fields()[0].schema(), other.str);
            fieldSetFlags()[0] = true;
         }
      }

      /**
       * Gets the value of the 'str' field.
       *
       * @return The value.
       */
      public java.lang.String getStr() {
         return str;
      }


      /**
       * Sets the value of the 'str' field.
       *
       * @param value The value of 'str'.
       * @return This builder.
       */
      public Builder setStr(java.lang.String value) {
         validate(fields()[0], value);
         this.str = value;
         fieldSetFlags()[0] = true;
         return this;
      }

      /**
       * Checks whether the 'str' field has been set.
       *
       * @return True if the 'str' field has been set, false otherwise.
       */
      public boolean hasStr() {
         return fieldSetFlags()[0];
      }


      /**
       * Clears the value of the 'str' field.
       *
       * @return This builder.
       */
      public Builder clearStr() {
         str = null;
         fieldSetFlags()[0] = false;
         return this;
      }

      @Override
      @SuppressWarnings("unchecked")
      public FooStringJava build() {
         try {
            FooStringJava record = new FooStringJava();
            record.str = fieldSetFlags()[0] ? this.str : (java.lang.String) defaultValue(fields()[0]);
            return record;
         } catch (org.apache.avro.AvroMissingFieldException e) {
            throw e;
         } catch (java.lang.Exception e) {
            throw new org.apache.avro.AvroRuntimeException(e);
         }
      }
   }

   @SuppressWarnings("unchecked")
   private static final org.apache.avro.io.DatumWriter<FooStringJava>
      WRITER$ = (org.apache.avro.io.DatumWriter<FooStringJava>) MODEL$.createDatumWriter(SCHEMA$);

   @Override
   public void writeExternal(java.io.ObjectOutput out)
      throws java.io.IOException {
      WRITER$.write(this, SpecificData.getEncoder(out));
   }

   @SuppressWarnings("unchecked")
   private static final org.apache.avro.io.DatumReader<FooStringJava>
      READER$ = (org.apache.avro.io.DatumReader<FooStringJava>) MODEL$.createDatumReader(SCHEMA$);

   @Override
   public void readExternal(java.io.ObjectInput in)
      throws java.io.IOException {
      READER$.read(this, SpecificData.getDecoder(in));
   }

   @Override
   protected boolean hasCustomCoders() {
      return true;
   }

   @Override
   public void customEncode(org.apache.avro.io.Encoder out)
      throws java.io.IOException {
      out.writeString(this.str);

   }

   @Override
   public void customDecode(org.apache.avro.io.ResolvingDecoder in)
      throws java.io.IOException {
      Schema.Field[] fieldOrder = in.readFieldOrderIfDiff();
      if (fieldOrder == null) {
         this.str = in.readString();

      } else {
         for (int i = 0; i < 1; i++) {
            switch (fieldOrder[i].pos()) {
               case 0:
                  this.str = in.readString();
                  break;

               default:
                  throw new java.io.IOException("Corrupt ResolvingDecoder.");
            }
         }
      }
   }
}










